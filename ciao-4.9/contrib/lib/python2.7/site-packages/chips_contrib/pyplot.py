#
#  Copyright (C) 2013, 2015, 2016
#            Smithsonian Astrophysical Observatory
#
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

"""
Create a *limited* matplotlib.pyplot-like interface to ChIPS:

Supported functions:

  autoscale
  axes
  axhline
  axhspan
  axis
  axvline
  axvspan
  bar
  barh
  clf
  clim
  close
  colorbar
  contour
  delaxes
  errorbar
  figtext
  figure
  grid
  hist
  hlines
  imshow
  loglog
  minorticks_off
  minorticks_on
  plot
  savefig
  scatter
  show
  subplot
  text
  title
  twinx
  twiny
  vlines
  xlabel
  xlim
  xscale
  ylabel
  ylim
  yscale

Not all arguments or behavior is supported: some unsopported items
are skipped and some replaced by an alternative. A screen message
may be displayed the first time this happens in a session.

The color cycling attempts to match that of matplotlib for simple cases
but does not produce the same results in all cases; for instance if
twinx and/or twiny is used then matplptlib resets the colors whereas
this module does not.

There is no support for masked NumPy arrays.

Minor tick marks are displayed by default, unlike matplotlib.

The rcParams dictionary is not emulated.

Many attributes (e.g. line styles) are mimicked as closely as
possible, but not all matplotlib values are supported, so some are
ignored. At present the color support only handles strings (whether
the short form, such as 'b', or the color name, 'blue')

"""

import collections

import six

import numpy as np

import pychips
import pychips.advanced

from crates_contrib.images import imextent
from chips_contrib.decorators import add_chips_undo_buffer

__all__ = (
    "autoscale", "axes", "axhline", "axhspan", "axis", "axvline", "axvspan",
    "bar", "barh",
    "clf", "clim", "close", "colorbar", "contour",
    "delaxes",
    "errorbar",
    "figtext", "figure",
    "grid",
    "imshow",
    "loglog",
    "minorticks_off", "minorticks_on",
    "plot",
    "savefig", "scatter", "subplot",
    "text", "title",
    "twinx", "twiny",
    "xlabel", "xlim", "xscale",
    "ylabel", "ylim", "yscale",
)

_notify_cache = set()


def _notify(msg, cache=True):
    """Display the message to the user on stdout unless
    it has been displayed before (and cache=True).
    """

    if cache and msg in _notify_cache:
        return

    print(msg)
    _notify_cache.add(msg)


# Set default settings.
# TODO: do this on-demand so that we do not create the ChIPS
#       server on module load
#
# Window measurements are approximate
pychips.set_preferences(["window.width", 8,
                         "window.height", 6,
                         "window.units", "inches",
                         "window.smoothing", "true",
                         "foreground.display", "black",
                         "foreground.file", "black",
                         "background.display", "white",
                         "background.file", "white",
                         "export.format", "png",
                         "axis.pad", 0,
                         "axis.majortick.mode", "nice",  # an experiment
                         ])

# "axis.minortick.visible", "false", # does not hide border minor tick marks
# "frame.bgcolor", "bfbfbf", # do not do as do not want in hardcopy


def _get_id(ostr):
    "Given an info string of the form '  AAA [bbb]' return (AAA, bbb)"

    ostr = ostr.strip()
    spos = ostr.find("[")
    if spos == -1:
        raise ValueError("No [ in {}".format(ostr))
    oname = ostr[:spos - 1]
    spos += 1
    epos = ostr.find("]", spos)
    if epos == -1:
        raise ValueError("No ] in {}".format(ostr))
    oid = ostr[spos:epos]
    return (oname, oid)


def _get_objects(cstr=None):
    """Parse the string (if not given, use the output of
    pychips.info), returning an array of windows, each of which is an
    array of frames, each of which is an array of plots, which
    contains a dictionary, each key containing a list of ChipsId
    objects. You lose the ordering of the different object types
    within a plot.

    An empty list is returned if there are no ChIPS objects.

    TODO: ensure info preference settings are over-ridden
    """

    if cstr is None:
        cstr = pychips.info()

    out = []
    if cstr is None:
        return out

    def mk(typename, idval, children):
        return {'type': typename, 'id': idval, 'children': children}

    for lobj in cstr.split("\n"):
        if (lobj.strip() == "") or (lobj.find("Border bottom [") != -1) \
           or (lobj.find("Coord Sys ") != -1):
            continue

        # Could track level/change of depth from the number of spaces
        # before the object name on each line, but for now do it
        # manually.
        #
        (oname, oid) = _get_id(lobj)
        if oname == "Window":
            out.append(mk('Window', pychips.ChipsId(oid), []))

        elif oname == "Frame":
            cwin = out[-1]
            idval = pychips.ChipsId(cwin["id"].window, oid)
            cwin["children"].append(mk('Frame', idval, []))

        elif oname == "Plot":
            cfrm = out[-1]["children"][-1]
            idval = pychips.ChipsId(cfrm["id"].window, cfrm["id"].frame, oid)
            cfrm["children"].append(mk('Plot', idval, {}))

        else:
            cplot = out[-1]["children"][-1]["children"][-1]
            obj = pychips.ChipsId(cplot["id"].window,
                                  cplot["id"].frame,
                                  cplot["id"].plot)

            attr = oname.lower().replace(" ", "")
            try:
                setattr(obj, attr, oid)
            except NameError:
                print("Internal error: skipping '{}'".format(lobj))

            try:
                cplot["children"][oname].append(obj)
            except KeyError:
                cplot["children"][oname] = [obj]

    return out


def _get_current_plots():
    """Return a list of ChipsId objects with the window/frame/plot name
    for the current plot(s). The array is empty if there are none."""

    cstr = pychips.info_current()
    if cstr is None:
        return []

    if cstr.find("Plot [") == -1:
        return []

    # Number of ways this could be done
    out = []
    cobj = []
    for lobj in cstr.split("\n"):
        if lobj.strip() == "":
            continue
        (oname, oid) = _get_id(lobj)
        if oname == "Window":
            cobj = [oid]
        elif oname == "Frame":
            cobj = [cobj[0], oid]
        elif oname == "Plot":
            ans = pychips.ChipsId(cobj[0], cobj[1], oid)
            out.append(ans)

    return out


_default_colors = [
    "blue", "008000", "red", "00bfbf",
    "bf00bf", "bfbf00", "black"
]


# TODO:
#   we could change the prefix for pyplot-created objects,
#   so that instead of crv1 ... we have pyplot-crv1 ...
#   and then only look at those with labels starting with
#   'pyplot-'. Not sure if it is really that good an idea.
#
def _get_next_color(itemtype):
    """Get the next color to use in the current plot. itemtype
    must be the string identifier used in the current output,
    e.g. 'Curve'.

    Note that it is not guaranteed to match the pyplot behavior,
    just to approximate it in the simple case. The idea is to
    query the current state to find out the next color, not to
    track the values as we go along since that is likely to
    be problematic (e.g. since we can not then track what
    happens from the ChIPS GUI).
    """

    cplots = _get_current_plots()
    if cplots == []:
        return _default_colors[0]

    # Is the caching here worth while?
    seen = {}
    nobj = 0
    for cplot in cplots:
        # Restrict info to current window/frame
        label = cplot.window + cplot.frame
        try:
            objs = seen[label]
        except KeyError:
            cstr = pychips.info(cplot)
            if cstr is None:
                # should not happen, but trap in case
                continue

            objs = _get_objects(cstr)
            if objs == []:
                # should not happen, but trap in case
                continue

            seen[label] = objs

        try:
            plots = objs[0]['children'][0]['children']
        except (IndexError, KeyError):
            continue

        plots = [plot for plot in plots if plot['id'].plot == cplot.plot]
        if len(plots) == 0:
            continue
        elif len(plots) > 1:
            print("Internal error - found multiple plots for {}.{}.{}".format(cplot.window, cplot.frame, cplot.plot))
            continue

        plot = plots[0]
        try:
            plotobjs = plot['children'][itemtype]
        except KeyError:
            continue

        nobj = len(plotobjs)
        break

    return _default_colors[nobj % len(_default_colors)]


_linestyles = {
    'None': 'noline',
    '-': 'solid',
    # The use of dot doesn't work so well with window.smoothing turned on,
    # so move "up" a size
    # '--': 'shortdash',
    # '-.': 'dotshortdash',
    # ':': 'dot',
    '--': 'longdash',
    '-.': 'shortdashlongdash',
    ':': 'shortdash',
    ' ': 'noline',
    '': 'noline',

    # contour styles
    # 'dashed': 'shortdash',
    # 'dashdot': 'dotshortdash',
    # 'dotted': 'dot',
    'dashed': 'longdash',
    'dashdot': 'shortdashlongdash',
    'dotted': 'shortdash',

    'solid': 'solid',
}


def _convert_linestyle(ls):
    "Convert pyplot linestyle into something that ChIPS can use"

    try:
        return _linestyles[ls]
    except KeyError:
        _notify("Unsupported line style of {}, replacing with solid".format(ls))
        return "solid"


_markerstyles = {
    None: None,
    'None': None,
    ' ': None,
    '': None,

    # centers are not the same for ChIPS and pyplot
    7: {'style': 'downtriangle'},
    6: {'style': 'uptriangle'},
    5: {'style': 'uptriangle', 'angle': -90},
    4: {'style': 'uptriangle', 'angle': 90},

    # centers may not be the same
    'v': {'style': 'downtriangle'},
    '^': {'style': 'uptriangle'},
    '>': {'style': 'uptriangle', 'angle': -90},
    '<': {'style': 'uptriangle', 'angle': 90},

    '+': {'style': 'plus'},
    'x': {'style': 'cross'},
    ',': {'style': 'point'},
    '.': {'style': 'circle', 'size': 2},

    'o': {'style': 'circle'},
    # ChIPS does not differentiate diamond and thin_diamond
    'd': {'style': 'diamond'},
    'D': {'style': 'diamond'},
    's': {'style': 'square'},

}


def _convert_marker(ms):
    "Convert pyplot markerstyle into something that ChIPS can use"

    try:
        return _markerstyles[ms]
    except KeyError:
        _notify("Unsupported marker style of {}, replacing with circle".format(ms))
        return {'style': 'circle'}


def _get_kwarg(kwargs, defval, name, conv=None):
    """Return the value of name from kwargs,
    using defval if not present.

    If the value is given and conv is not None return conv(value)
    rather than value.
    """

    try:
        rval = kwargs[name]
    except KeyError:
        return defval

    if conv is None:
        return rval
    else:
        return conv(rval)


def _get_kwarg2(kwargs, defval, name1, name2, conv=None):
    """Return the value of name1 then, if not present name2 from kwargs,
    falling over to defval if neither are present.

    If the value is given and conv is not None return conv(value)
    rather than value.
    """

    try:
        rval = kwargs[name1]
    except KeyError:
        try:
            rval = kwargs[name2]
        except:
            return defval

    if conv is None:
        return rval
    else:
        return conv(rval)


def _get_kwarg3(kwargs, defval, name1, name2, name3, conv=None):
    """Return the value of name1 then, if not present name2 from kwargs,
    and if that is not present, name3 from kwargs,
    falling over to defval if neither are present.

    If the value is given and conv is not None return conv(value)
    rather than value.
    """

    try:
        rval = kwargs[name1]
    except KeyError:
        try:
            rval = kwargs[name2]
        except:
            try:
                rval = kwargs[name3]
            except:
                return defval

    if conv is None:
        return rval
    else:
        return conv(rval)


def _handle_plot_args(*args):
    """Given arguments to plot(), return an array of
    curves to plot. I do not think this matches the
    logic of matplotlib but hopefully close enough.
    """

    # we use store to store the array arguments to plot and
    # to determine what 'state' we are in.
    #
    out = []
    store = []
    for arg in args:
        state = len(store)
        isstring = isinstance(arg, six.string_types)
        if state == 0:
            if isstring:
                raise ValueError("Expected array but found a string '{}'.".format(arg))
            arry = np.atleast_1d(arg)
            if arry.ndim > 2:
                raise ValueError("Array must be 1D or 2D, not {}D.".format(arry.ndim))
            store.append(arry)

        elif state == 1:
            if isstring:
                out.append({"type": "y", "y": store[0], "opts": arg})
                store = []

            else:
                arry = np.atleast_1d(arg)
                if arry.ndim > 2:
                    raise ValueError("Array must be 1D or 2D, not {}D.".format(arry.ndim))
                store.append(arry)

        elif state == 2:
            outval = {"type": "xy", "x": store[0], "y": store[1]}
            nx = store[0].shape[0]
            ny = store[1].shape[0]
            if nx != ny:
                raise ValueError("x and y must have the same first dimension: {} vs {}".format(nx, ny))
            if isstring:
                outval["opts"] = arg
                store = []

            else:
                arry = np.atleast_1d(arg)
                if arry.ndim > 2:
                    raise ValueError("Array must be 1D or 2D, not {}D.".format(arry.ndim))
                store = [arry]

            out.append(outval)

        else:
            raise RuntimeError("Internal error: too many elements in store={}".format(store))

    state = len(store)
    if state == 0:
        pass
    elif state == 1:
        out.append({"type": "y", "y": store[0]})
    elif state == 2:
        out.append({"type": "xy", "x": store[0], "y": store[1]})
    else:
        raise RuntimeError("Internal error: too many elements in store={}".format(store))

    return out


_color1map = {
    'b': "blue",
    'g': "008000",
    'r': "red",
    'c': "00bfbf",
    'm': "bf00bf",
    'y': "bfbf00",
    'k': "black",
    'w': "white"
}


def _convert_color(colname):
    """Expand out one-letter color-name combinations,
    leaving everything else as is. Raises a ValueError
    if the resulting color spec is not recognized.
    """

    try:
        colval = _color1map[colname]
    except KeyError:
        colval = colname

    if not pychips.advanced.valid_color(colval):
        raise ValueError("Unsupported color of '{}'".format(colname))

    return colval


def _parse_plot_opts(opts, copts):
    """Update the ChipsCurve object copts with the
    plot options given as a string.
    """

    symbol = False
    linestyle = False
    while opts != '':
        fchar = opts[0]
        try:
            newcol = _color1map[fchar]
            copts.line.color = newcol
            copts.symbol.color = newcol
            opts = opts[1:]
            continue

        except KeyError:
            pass

        try:
            cstyle = _markerstyles[fchar]
            for (key, value) in six.iteritems(cstyle):
                setattr(copts.symbol, key, value)

            opts = opts[1:]
            symbol = True
            continue

        except KeyError:
            pass

        # just hard code the linestyles for now
        if opts.startswith('--'):
            n = 2
        elif opts.startswith('-.'):
            n = 2
        elif fchar in '-:':
            n = 1
        else:
            _notify("Skipping unsupported plot option '{}'".format(fchar))
            n = None

        if n is not None:
            copts.line.style = _convert_linestyle(opts[:n])
            linestyle = True
        else:
            n = 1

        opts = opts[n:]

    if symbol and not linestyle:
        copts.line.style = "noline"


def _get_curve_opts(argstr=None, **kwargs):
    """Return a ChipsCurve object given a pyplot.plot
    options string and keyword arguments. The keyword arguments
    override the argstr value if both are present.

    For now living with the repeated search of the kwargs
    values when multiple curves are plotted.
    """

    copts = pychips.ChipsCurve()

    if argstr is not None:
        _parse_plot_opts(argstr, copts)

    copts.line.thickness = _get_kwarg2(kwargs, 1, 'linewidth', 'lw')

    ls = _get_kwarg2(kwargs, None, 'linestyle', 'ls', _convert_linestyle)
    if ls is not None:
        copts.line.style = ls

    if copts.symbol.style is None:
        ms = _get_kwarg(kwargs, None, 'marker', _convert_marker)
        if ms is None:
            copts.symbol.style = "none"
        else:
            for (key, value) in six.iteritems(ms):
                setattr(copts.symbol, key, value)

            ms = _get_kwarg2(kwargs, 5, 'markersize', 'ms')
            if copts.symbol.size is None:
                copts.symbol.size = int(ms)
            else:
                # scale the current size (not sure if this is
                # worthwhile, but trying to support scaling marker='.'
                # which is a "small" circle")
                copts.symbol.size = int(ms * 1.0 * copts.symbol.size / 5.0)

    defcolor = _get_kwarg2(kwargs, copts.line.color, 'color', 'c')
    if defcolor is None:
        copts.line.color = _get_next_color("Curve")
    else:
        copts.line.color = _convert_color(defcolor)

    copts.symbol.color = copts.line.color

    return copts


# matplot uses matplotlib.font_manager.font_scalings as a scaling for
# a default font size. We apply these scalings to the default font size
#
_font_scalings = {
    'large': 1.2,
    'larger': 1.2,
    'medium': 1.0,
    'small': 0.833,
    'smaller': 0.833,
    'x-large': 1.44,
    'x-small': 0.694,
    'xx-large': 1.728,
    'xx-small': 0.579
}


def _convert_fontsize(fs):
    "Convert from matplotlib to ChIPS"

    try:
        scale = _font_scalings[fs]
    except KeyError:
        return int(fs)

    base = int(pychips.get_preference('label.size'))
    return int(scale * base)


def _convert_fontstyle(fs):
    if fs in ['normal', 'italic']:
        return fs
    elif fs == 'oblique':
        _notify("Ignoring fontstyle of {}".format(fs))
        return 'normal'
    else:
        raise ValueError("Unsupported font style: {}".format(fs))


def _convert_fontweight(fw):
    if fw in ['ultralight', 'light', 'normal', 'regular', 'book', 'medium', 'roman']:
        return 'normal'
    elif fw in ['semibold', 'demibold', 'demi', 'bold', 'heavy', 'extra bold', 'black']:
        return 'bold'
    elif fw <= 500:
        return 'normal'
    else:
        return 'bold'


_valign_vals = {
    'top': 1.0,
    'center': 0.5,
    'bottom': 0,
    'baseline': 0.1,  # A GUESS
}


def _convert_valign(va):
    "Unlike halign, not all valign values are supported in ChIPS"

    try:
        return _valign_vals[va]
    except KeyError:
        raise ValueError("Unsupported valign value: {}".format(va))


# Use a dictionary rather than an array or a ChipsXXX object
def _handle_text_args(opts, **kwargs):
    "Append text-relevant kw pairs to the options array"

    c = _get_kwarg2(kwargs, None, 'color', 'c', _convert_color)
    if c is not None:
        opts['color'] = c

    fs = _get_kwarg2(kwargs, None, 'fontsize', 'size', _convert_fontsize)
    if fs is not None:
        opts['size'] = fs

    # Neet to combine fontstyle and fontweight arguments; probably OTT
    # given that the logic can't match
    fs = _get_kwarg2(kwargs, None, 'fontstyle', 'style', _convert_fontstyle)
    fw = _get_kwarg2(kwargs, None, 'fontweight', 'weight', _convert_fontweight)
    if fs is not None or fw is not None:
        if fs == 'normal' and fw == 'normal':
            fontstyle = 'normal'
        elif (fs in ['normal', None]) and fw == 'bold':
            fontstyle = 'bold'
        elif (fw in ['normal', None]) and fs == 'italic':
            fontstyle = 'italic'
        elif fs == 'italic' and fw == 'bold':
            fontstyle = 'bolditalic'
        else:
            # should not be possible unless my logic is in error or
            # new values are allowed for fs/fw
            fontstyle = None

        if fontstyle is not None:
            opts['fontstyle'] = fontstyle

    ha = _get_kwarg2(kwargs, None, 'horizontalalignment', 'ha')
    if ha is not None:
        opts['halign'] = ha

    va = _get_kwarg3(kwargs, None, 'verticalalignment', 'va', 'ma',
                     _convert_valign)
    if va is not None:
        opts['valign'] = va

    angle = _get_kwarg(kwargs, None, 'rotation')
    if angle == 'vertical':
        opts['angle'] = 90
    elif angle == 'horizontal':
        opts['angle'] = 0
    elif angle is not None:
        opts['angle'] = angle


def _scale_ncoords(rfunc, n1, n2):
    """Given normalized coordinates n1 and n2 (0 to 1), and
    a routine to return the axis data range, return the
    corresponding data coordinates of n1 and n2."""

    (start, end) = rfunc()
    delta = end - start
    d1 = start + n1 * delta
    d2 = start + n2 * delta
    return (d1, d2)


def _process_line_opts(**kwargs):
    "Return a dictionary for a line."

    c = _get_kwarg2(kwargs, _default_colors[0], 'color', 'c', _convert_color)
    lopts = {'color': c}

    lw = _get_kwarg2(kwargs, None, 'linewidth', 'lw')
    if lw is not None:
        lopts['thickness'] = lw

    ls = _get_kwarg2(kwargs, None, 'linestyle', 'ls', _convert_linestyle)
    if ls is not None:
        lopts['style'] = ls

    return lopts


def _process_region_opts(**kwargs):
    "Return a dictionary for a region"

    ropts = {'fill.color': _default_colors[0],
             'edge.color': _default_colors[0],
             'depth': 50}

    a = _get_kwarg(kwargs, 1, 'alpha')
    ropts['opacity'] = a

    ec = _get_kwarg2(kwargs, None, 'edgecolor', 'ec', _convert_color)
    if ec is not None:
        ropts['edge.color'] = ec

    fc = _get_kwarg2(kwargs, None, 'facecolor', 'fc', _convert_color)
    if fc is not None:
        ropts['fill.color'] = fc

    c = _get_kwarg(kwargs, None, 'color', _convert_color)
    if c is not None:
        ropts['fill.color'] = c
        ropts['edge.color'] = c

    f = _get_kwarg(kwargs, None, 'fill')
    if f is not None:
        if f:
            ropts['fill.style'] = 'solid'
        else:
            ropts['fill.style'] = 'nofill'

    lw = _get_kwarg2(kwargs, None, 'linewidth', 'lw')
    if lw is not None:
        ropts['edge.thickness'] = lw

    ls = _get_kwarg2(kwargs, None, 'linestyle', 'ls', _convert_linestyle)
    if ls is not None:
        ropts['edge.style'] = ls

    return ropts


def _get_new_axis_limits(axchar, kwargs, minval=None, maxval=None):
    """Returns minval,maxval for the axis given by axchar ('x' or 'y')
    if either minval or maxval arguments are not None, or they are set
    in the kwargs dictionary (kwargs overrides the minval/maxval arguments).

    If neither is set then None,None is returned, and if only one is set then
    the current value for the other limit is used.
    """

    if axchar == 'x':
        get_range = pychips.get_plot_xrange
        get_axis = pychips.get_xaxis
    elif axchar == 'y':
        get_range = pychips.get_plot_yrange
        get_axis = pychips.get_yaxis
    else:
        raise ValueError("Internal error: expected x or y but sent axchar={}".format(axchar))

    minval = _get_kwarg(kwargs, minval, axchar + "min")
    maxval = _get_kwarg(kwargs, maxval, axchar + "max")

    if minval is None and maxval is None:
        return (None, None)

    cur = get_range()
    ax = get_axis()

    if maxval is None:
        if ax.automax:
            maxval = pychips.AUTO
        else:
            maxval = cur[1]

    if minval is None:
        if ax.automin:
            minval = pychips.AUTO
        else:
            minval = cur[0]

    return (minval, maxval)


def _axlimits(axtype, *args, **kwargs):
    "Worker for xlim/ylim"

    if axtype == pychips.X_AXIS:
        get_range = pychips.get_plot_xrange
        set_axis = pychips.set_xaxis
        fchar = 'x'

    elif axtype == pychips.Y_AXIS:
        get_range = pychips.get_plot_yrange
        set_axis = pychips.set_yaxis
        fchar = 'y'

    else:
        raise ValueError("Internal error: unsupported axtype={}".format(axtype))

    minval = None
    maxval = None
    nargs = len(args)
    if nargs == 1:
        if isinstance(args[0], collections.Iterable):
            (minval, maxval) = args[0]
        else:
            minval = args[0]

    elif nargs > 1:
        minval = args[0]
        maxval = args[1]

    # The named arguments override the positional ones
    (minval, maxval) = _get_new_axis_limits(fchar, kwargs, minval, maxval)

    if minval is not None:
        @add_chips_undo_buffer()
        def doit():
            set_axis(['majortick.mode', 'limits'])
            pychips.limits(axtype, minval, maxval)

        doit()

    ans = get_range()
    return tuple(ans)


# pyplot commands

def autoscale(enable=True, axis='both', tight=None):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.autoscale

    The enable attribute does not work the same as pyplot:
       enable = True  - call limits on the axis with AUTO,AUTO
       enable = False - sets automin/max of the axis to False
       enable = None  - do nothing

    The tight attribute is not handled the same as pyplot:
       tight = True   - majortick.mode to limits
       tight = False  - majortick.mode to nice
       tight = None   - do nothing

    """

    if axis == 'both':
        axtype = pychips.XY_AXIS
        axfunc = pychips.set_axis
    elif axis == 'x':
        axtype = pychips.X_AXIS
        axfunc = pychips.set_xaxis
    elif axis == 'y':
        axtype = pychips.Y_AXIS
        axfunc = pychips.set_yaxis
    else:
        raise ValueError("Unsupported axis='{}' argument.".format(axis))

    commands = []
    axopts = []

    if enable is not None:
        if enable:
            # would like to set automin/max fields to True
            # but not convinced that does quite the right thing
            # (does not seem to rescale based on the data range
            # but the actual axis limits)
            #
            commands.append((pychips.limits,
                             (axtype, pychips.AUTO, pychips.AUTO)))
        else:
            axopts.extend(["automin", False, "automax", False])

    if tight is not None:
        if tight:
            modeval = "limits"
        else:
            modeval = "nice"

        axopts.extend(["majortick.mode", modeval])

    if commands == [] and axopts == []:
        return

    @add_chips_undo_buffer()
    def doit():
        for (cfunc, cargs) in commands:
            cfunc(*cargs)

        if axopts != []:
            axfunc(axopts)

    doit()


def axes(*args, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.axes

    This is translated into an add_plot() call. The option where an axes
    instance is input is not supported here.

    The axisbg argument is supported, and a region is placed at depth=10 below
    the plot with the color, for all colors but white. This is an experimental
    feature and may well be removed.

    Keywords:
      axisbg   - if set, and frameon=True, then place a region at depth=10
                 below the plot. This is experimental
      frameon  - only used when axisbg is set (does not match pyplot behavior)
      sharex   - currently ignored
      sharey   - currently ignored
      polar    - errors out if set to True
    """

    commands = []
    if len(args) == 0:
        commands.append((pychips.add_plot, []))
    elif len(args) == 1:
        # assume 4 element array
        if len(args[0]) != 4:
            raise ValueError("axes only supports a 4-element array for its optional argument.")
        (l, b, w, h) = args[0]
        commands.append((pychips.add_plot, (l, b, l + w, b + h)))

    elif len(args) > 1:
        raise TypeError("axes takes 0 or 1 non-keyword arguments.")

    commands.append((pychips.add_axis, (pychips.XY_AXIS, 0, 0, 1)))

    polar = _get_kwarg(kwargs, False, 'polar')
    if polar:
        raise ValueError("polar plots are not supported")

    frameon = _get_kwarg(kwargs, True, 'frameon')
    if not frameon:
        _notify("frameon=False is not fully supported for axes()")

    bgcol = _get_kwarg(kwargs, None, 'axisbg')
    if frameon and bgcol is not None:
        bgcol = _convert_color(bgcol)
        commands.append(pychips.add_region,
                        ([0, 1, 1, 0], [0, 0, 1, 1],
                         ['coordsys', pychips.PLOT_NORM,
                          'fill.color', bgcol, 'fill.style', 'solid',
                          'edge.style', 'noline',
                          'opacity', 1,
                          'depth', 10]))

    @add_chips_undo_buffer()
    def doit():
        for (cfunc, cargs) in commands:
            cfunc(*cargs)

    doit()


def axhline(y=0, xmin=0, xmax=1, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.axhline

    The xmin/xmax values are currently converted to data coordinates
    if either is changed from its default value (ChIPS does not
    support coordinates in two different coordinate systems and it is
    likely better to ensure the line stays at the given y value rather
    than converting it to plot-normalized coordinates so that
    xmin/xmax can be changed).

    Supported keywords:

      color or c
      linestyle or ls
      linewidth or lw

    """

    lopts = _process_line_opts(**kwargs)

    if xmin == 0 and xmax == 1:
        pychips.add_hline(y, lopts)
        return

    _notify("Since xmin or xmax has been set, axhline is being positioned in data coordinates")
    (x0, x1) = _scale_ncoords(pychips.get_plot_xrange, xmin, xmax)
    pychips.add_line(x0, y, x1, y, lopts)


def axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.axhspan

    The coordinates are always converted to data coordinates (ChIPS does not
    support coordinates in two different coordinate systems and it is
    likely better to ensure the region stays at the given y range rather
    than converting it to plot-normalized coordinates so that
    xmin/xmax can be changed).

    The region is placed at a depth of 50 to appear behind other plot objects.

    Supported keywords:

      alpha
      color
      edgecolor or ec
      facecolor or fc
      fill
      linestyle or ls
      linewidth or lw

    """

    ropts = _process_region_opts(**kwargs)

    _notify('The region created by axhspan is being positioned in data coordinates')
    (x0, x1) = _scale_ncoords(pychips.get_plot_xrange, xmin, xmax)
    ycoords = [ymin, ymin, ymax, ymax]
    xcoords = [x0, x1, x1, x0]
    pychips.add_region(xcoords, ycoords, ropts)


def axvline(x=0, ymin=0, ymax=1, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.axvline

    The xmin/xmax values are currently converted to data coordinates
    if either is changed from its default value (ChIPS does not
    support coordinates in two different coordinate systems and it is
    likely better to ensure the line stays at the given y value rather
    than converting it to plot-normalized coordinates so that
    xmin/xmax can be changed).

    Supported keywords:

      color or c
      linestyle or ls
      linewidth or lw

    """

    lopts = _process_line_opts(**kwargs)

    if ymin == 0 and ymax == 1:
        pychips.add_vline(x, lopts)
        return

    _notify("Since ymin or ymax has been set, axvline is being positioned in data coordinates")
    (y0, y1) = _scale_ncoords(pychips.get_plot_yrange, ymin, ymax)
    pychips.add_line(x, y0, x, y1, lopts)


def axis(*v, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.axis

    Supported values:
       on, off, equal, scaled, tight, and image

    although the behavior is not guaranteed to match that of pyplot.
    The auto and normal arguments are ignored.

    If 4 arguments are given then they are used as the new axis limits.
    If no argument is given then the xmin, xmax, ymin, and ymax keywords
    are used to change the axis limit(s).

    The axis limits are returned as a tuple: xmin, xmax, ymin, ymax
    """

    commands = []

    if len(v) == 1:
        arg = v[0]
        # use of all for on/off in the display/hide calls is not quite right
        # but makes things easier here
        if arg == 'on':
            commands.append((pychips.display_axis, ('all', )))
            commands.append((pychips.set_plot, (['style', 'closed'], )))
        elif arg == 'off':
            commands.append((pychips.hide_axis, ('all', )))
            commands.append((pychips.set_plot, (['style', 'open'], )))
        elif arg == 'equal':
            # should this turn off plot aspect ratio if set?
            commands.append((pychips.set_data_aspect_ratio, ('1:1', )))
        elif arg == 'scaled':
            # should this turn off data aspect ratio if set?
            commands.append((pychips.set_plot_aspect_ratio, ('1:1', )))
        elif arg == 'tight':
            # skipping the "if all the data is shown, just recenter"
            commands.append((pychips.limits, (pychips.X_AXIS,
                                              pychips.AUTO,
                                              pychips.AUTO)))
            commands.append((pychips.limits, (pychips.Y_AXIS,
                                              pychips.AUTO,
                                              pychips.AUTO)))
        elif arg == 'image':
            # probably not the same behavior
            commands.append((pychips.limits, (pychips.X_AXIS,
                                              pychips.AUTO,
                                              pychips.AUTO)))
            commands.append((pychips.limits, (pychips.Y_AXIS,
                                              pychips.AUTO,
                                              pychips.AUTO)))
            # should this turn off data aspect ratio if set?
            commands.append((pychips.set_plot_aspect_ratio, ('1:1', )))
        elif arg in ['auto', 'normal']:
            _notify("Ignoring axis('{}') command".format(arg))
        else:
            raise ValueError("Unrecognized axis argument: {}".format(arg))

    elif len(v) == 4:
        (xmin, xmax, ymin, ymax) = v
        commands.append((pychips.set_axis, (['majortick.mode', 'limits'], )))
        commands.append((pychips.limits, (xmin, xmax, ymin, ymax)))

    elif len(v) == 0:
        (xmin, xmax) = _get_new_axis_limits('x', kwargs, None, None)
        (ymin, ymax) = _get_new_axis_limits('y', kwargs, None, None)
        if xmin is not None or ymin is not None:
            if xmin is None:
                commands.append((pychips.set_yaxis,
                                 (['majortick.mode', 'limits'], )))
                commands.append((pychips.limits,
                                 (pychips.Y_AXIS, ymin, ymax)))
            elif ymin is None:
                commands.append((pychips.set_xaxis,
                                 (['majortick.mode', 'limits'], )))
                commands.append((pychips.limits,
                                 (pychips.X_AXIS, xmin, xmax)))
            else:
                commands.append((pychips.set_axis,
                                 (['majortick.mode', 'limits'], )))
                commands.append((pychips.limits, (xmin, xmax, ymin, ymax)))

    else:
        raise ValueError("Either zero, one or four arguments")

    if commands != []:
        @add_chips_undo_buffer()
        def doit():
            for (cfunc, cargs) in commands:
                cfunc(*cargs)

        doit()

    ans = pychips.get_plot_range()
    return tuple(ans)


def axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.axvspan

    The coordinates are always converted to data coordinates (ChIPS does not
    support coordinates in two different coordinate systems and it is
    likely better to ensure the region stays at the given x range rather
    than converting it to plot-normalized coordinates so that
    ymin/ymax can be changed).

    The region is placed at a depth of 50 to appear behind other plot objects.

    Supported keywords:

      alpha
      color
      edgecolor or ec
      facecolor or fc
      fill
      linestyle or ls
      linewidth or lw

    """

    ropts = _process_region_opts(**kwargs)

    _notify('The region created by axvspan is being positioned in data coordinates')
    (y0, y1) = _scale_ncoords(pychips.get_plot_yrange, ymin, ymax)
    xcoords = [xmin, xmin, xmax, xmax]
    ycoords = [y0, y1, y1, y0]
    pychips.add_region(xcoords, ycoords, ropts)


# TODO: support sequences for the keywords (e.g. facecolor)
def bar(left, height, width=0.8, bottom=None, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.bar

    Supported keywords (scalar values only):

      align
      orientation

      alpha
      color
      edgecolor or ec
      facecolor or fc
      fill
      linestyle or ls
      linewidth or lw

    Note that ChIPS does not include regions when autoscaling axis limits,
    which is different to matplotlib.

    Support for arrays of alpha/color/... options could be added.
    """

    align = _get_kwarg(kwargs, 'edge', 'align')
    orientation = _get_kwarg(kwargs, 'vertical', 'orientation')
    if align not in ['edge', 'center']:
        raise ValueError("Invalid align={}".format(align))
    if orientation not in ['vertical', 'horizontal']:
        raise ValueError("Invalid orientation={}".format(orientation))

    ropts = _process_region_opts(**kwargs)

    if bottom is None:
        bottom = 0

    left = np.atleast_1d(left)
    bottom = np.atleast_1d(bottom)
    width = np.atleast_1d(width)
    height = np.atleast_1d(height)
    nd = [n for n in [left, bottom, width, height] if n.ndim != 1]
    if nd != []:
        raise ValueError("Coordinate arguments must either be scalars or 1D arrays, found {}D array".format(nd[0]))

    ns = set([n.size for n in [left, bottom, width, height]])
    if len(ns) > 2:
        raise ValueError("Coordinate arguments must either be scalars or 1D arrays of the same size")
    nbars = max(ns)

    if nbars > 1:
        if left.size == 1: left = np.repeat(left, nbars)
        if bottom.size == 1: bottom = np.repeat(bottom, nbars)
        if width.size == 1: width = np.repeat(width, nbars)
        if height.size == 1: height = np.repeat(height, nbars)

    if orientation == 'vertical':
        ropts['stem'] = 'vbar'
        if align == 'edge':
            x0 = left
        else:
            x0 = left - 0.5 * width

        y0 = bottom
    else:
        ropts['stem'] = 'hbar'
        if align == 'edge':
            y0 = bottom
        else:
            y0 = bottom - 0.5 * height

        x0 = left

    x1 = x0 + width
    y1 = y0 + height

    commands = []
    for (a, b, c, d) in zip(x0, x1, y0, y1):
        commands.append((pychips.add_region,
                         ([a, b, b, a], [c, c, d, d], ropts)))

    @add_chips_undo_buffer()
    def doit():
        for (cfunc, cargs) in commands:
            cfunc(*cargs)

    doit()


def barh(bottom, width, height=0.8, left=None, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.barh

    See bar() for supported behavior and keywords
    """

    if left is None:
        left = 0

    bar(bottom=bottom, width=width, height=height, left=left, orientation='horizontal', **kwargs)


def clf():
    "See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.clf"

    pychips.erase()


def clim(vmin=None, vmax=None):
    "See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.clim"

    if vmin is None and vmax is None:
        return

    if vmin is None or vmax is None:
        ivals = pychips.get_image()
        if vmin is None:
            vmin = ivals.threshold[0]
        if vmax is None:
            vmax = ivals.threshold[1]

    pychips.set_image(['threshold', [vmin, vmax]])


def close(num=None):
    "See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.close"

    if num is None:
        name = None
    elif isinstance(num, six.string_types):
        name = num
    else:
        name = "win{}".format(num)

    try:
        if name is None:
            pychips.delete_window()
        else:
            pychips.delete_window(name)
    except RuntimeError:
        pass


def colorbar(mappable=None, cax=None, ax=None, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.colorbar

    The mappable, cax, and ax arguments must be letft as None.

    The only supported keywords are listed below, others are ignored:

        orientation
        fraction
        anchor   - approximate behavior to matplotlib
    """

    if mappable is not None:
        raise ValueError("At present mappable must be set to None")
    if cax is not None:
        raise ValueError("At present cax must be set to None")
    if ax is not None:
        raise ValueError("At present ax must be set to None")

    orientation = _get_kwarg(kwargs, 'vertical', 'orientation')

    # approximate the location
    if orientation == 'horizontal':
        xpos = 0.5
        ypos = 1.05
    elif orientation == 'vertical':
        xpos = 1.05
        ypos = 0.5
    else:
        raise ValueError("orientation must be horizontal or vertical, not {}".format(orientation))

    opts = {'orientation': orientation}
    length = _get_kwarg(kwargs, None, 'fraction')
    if length is not None:
        opts['length'] = length

    (xpos, ypos) = _get_kwarg(kwargs, (xpos, ypos), 'anchor')

    # approximate the pad settings; decided against this as would
    # have to re-size the plot, which is possible but too much
    # effort at this time
    #
    # pad = _get_kwarg(kwargs, None, 'pad')
    # if pad is not None:
    #     if orientation == 'horizontal':
    #         ypos = 1 + pad
    #     else:
    #         xpos = 1 + pad

    pychips.add_colorbar(xpos, ypos, opts)


def contour(*args, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.contour

    The contour support in ChIPS is much-more limited than in
    matplotlib; for instance no support for dashed lines for negative
    and solid lines for positive.

    We support

      contour(Z)
      contour(Z,V)
      contour(X,Y,Z)
      contour(X,Y,Z,V)

    The N version (giving the number of levels) is not supported.

    Supported keyword arguments (NOTE: scalar values only, since multiple
    values per contour are not supported):

      colors
      linewidths
      linestyles

    Note: the levels keyword is *NOT* supported at this time.

    """

    nargs = len(args)
    if nargs == 0:
        raise TypeError("No arrays supplied to contour")

    elif nargs > 4:
        raise TypeError("At present only support contour(Z)")

    else:
        copts = pychips.ChipsContour()
        copts.color = _get_kwarg(kwargs, None, 'colors', _convert_color)
        copts.thickness = _get_kwarg(kwargs, None, 'linewidths')
        copts.style = _get_kwarg(kwargs, None, 'linestyles',
                                 _convert_linestyle)

        # can do this since do not support the N version (giving the
        # number of levels)
        runargs = list(args)
        runargs.append(copts)
        pychips.add_contour(*runargs)


def delaxes(ax=None):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.delaxes

    We map the concept of a pair of axes to a ChIPS plot, so will delete
    the current plot. At present can not send in an identifier.
    """

    if ax is not None:
        raise ValueError("At present can not delete a specific axis pair")

    try:
        pychips.delete_plot()
    except RuntimeError:
        pass


def errorbar(x, y, yerr=None, xerr=None, fmt='-', ecolor=None,
             elinewidth=None, capsize=3, barsabove=False, lolims=False,
             uplims=False, xlolims=False, xuplims=False, errorevery=1,
             capthick=None, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.errorbar

    At present the supported keywords are
        xerr, yerr
        fmt
        ecolor, elinewidth, capsize

    and the same arguments as supported by plot().

    The x, y, xerr, and yerr values must have the same size and be
    1D.
    """

    opts = _get_curve_opts(fmt, **kwargs)
    if ecolor is not None:
        opts.err.color = _convert_color(ecolor)
    else:
        opts.err.color = opts.symbol.color
    opts.err.thickness = elinewidth
    opts.err.caplength = capsize
    opts.err.style = "capped"

    if xerr is not None or yerr is not None:
        errvals = []
        if xerr is None:
            errvals = yerr
        elif yerr is None:
            errvals = [None, None, xerr, xerr]
        else:
            errvals = [yerr, yerr, xerr, xerr]

        pychips.add_curve(x, y, errvals, opts)
    else:
        pychips.add_curve(x, y, opts)


@add_chips_undo_buffer()
def _add_text(x, y, s, vis, opts):
    pychips.add_label(x, y, s, opts)
    if not vis:
        pychips.hide_label()


def figtext(x, y, s, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.figtext

    See text for supported keyword arguments
    """

    opts = {'coordsys': pychips.FRAME_NORM}
    _handle_text_args(opts, **kwargs)
    vis = _get_kwarg(kwargs, True, 'visible')
    _add_text(x, y, s, vis, opts)


def figure(num=None, figsize=None, dpi=None, facecolor=None,
           edgecolor=None, frameon=True, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.figure

    At present the only supported keywords are
       num
       figsize
       facecolor - although does not behave the same as in matplotlib

    """

    opts = []
    if figsize is not None:
        (width, height) = figsize
        opts.extend(['width', width, 'height', height, 'units', 'inches'])

    fopts = []
    if facecolor is not None:
        fopts.extend(['bgcolor', _convert_color(facecolor)])

    if num is None:
        if opts == []:
            pychips.add_window()
        else:
            pychips.add_window(opts)

    else:
        if isinstance(num, six.string_types):
            name = num
        else:
            name = "win{}".format(num)

        try:
            pychips.set_current_window(name)
            return

        except RuntimeError:
            opts.extend(['id', name])
            pychips.add_window(opts)

    if fopts != []:
        pychips.add_frame(fopts)


def _get_grids(which='major'):
    "Return names of grid components"

    try:
        return {'major': ['major'],
                'minor': ['minor'],
                'both': ['major', 'minor']}[which]
    except KeyError:
        raise ValueError("Unsupported which={} setting".format(which))


def _get_axes(axis='both'):
    "Return getter/setter for axis setting"

    xaxis = (pychips.get_xaxis, pychips.set_xaxis)
    yaxis = (pychips.get_yaxis, pychips.set_yaxis)
    try:
        return {'x': [xaxis],
                'y': [yaxis],
                'both': [xaxis, yaxis]}[axis]
    except KeyError:
        raise ValueError("Unsupported axis={} setting".format(axis))


@add_chips_undo_buffer()
def _toggle_grid(axes, grids):
    "Toggle the setting of the grid."

    for (getfn, setfn) in axes:
        axinfo = getfn()
        opts = []
        for grid in grids:
            lbl = "{}grid".format(grid)
            opts.append("{}.visible".format(lbl))
            opts.append(not getattr(axinfo, lbl).visible)

        setfn(opts)


@add_chips_undo_buffer()
def _set_grid(axes, axopts):
    "Change the grid settings."

    for (getfn, setfn) in axes:
        setfn(axopts)


def grid(b=None, which='major', axis='both', **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.grid

    There appears to be some strange behavior if you toggle the settings
    a lot in ChIPS; something looks to get confused.

    This does not seem to match the observed behavior of matplotlib,
    in particular the minor grid visibility/interaction with the
    minorticks_on/off commands.

    Supported keywords:

      color or c
      linestyle or ls
      linewidth or lw

    """

    grids = _get_grids(which)
    axes = _get_axes(axis)

    # This is what the docs claim but the behavior seems to be that
    # b is set to True if any keyword is given, even if set to False.
    if b is None:
        if len(kwargs) == 0:
            _toggle_grid(axes, grids)
            return
        else:
            b = True

    axopts = pychips.ChipsAxis()
    lw = _get_kwarg2(kwargs, None, 'linewidth', 'lw')
    ls = _get_kwarg2(kwargs, None, 'linestyle', 'ls', _convert_linestyle)
    c = _get_kwarg2(kwargs, None, 'color', 'c', _convert_color)

    for grid in grids:
        lbl = "{}grid".format(grid)
        gridopts = getattr(axopts, lbl)
        gridopts.visible = b

        gridopts.thickness = lw
        gridopts.style = ls
        gridopts.color = c

    _set_grid(axes, axopts)


def hist(x, bins=10, range=None, normed=False, weights=None,
         cumulative=False, bottom=None, align='mid',
         orientation='vertical', rwidth=None, log=False,
         color=None, label=None, stacked=False, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.hist

    For now only works with a 1D x array.

    Supported arguments:
      orientation=vertical only
      stacked=False only
      cumulative=False only
      rwidth=None only
      log=False only

      histtype  - barstacked is not supported
      align     - left or right may not match pyplot

      color
      edgecolor or ec
      facecolor or fc
      fill
      linestyle or ls
      linewidth or lw

   The return value is a 3-tuple but the third element is None.
   """

    if orientation != 'vertical':
        raise NotImplementedError("The only supported orientation is vertical, not {}".format(orientation))
    if stacked:
        raise NotImplementedError("The stacked=True option is not supported.")
    if cumulative:
        raise NotImplementedError("The cumulative=True option is not supported.")
    if rwidth is not None:
        raise NotImplementedError("The rwidth option is not supported.")
    if log:
        raise NotImplementedError("The log=True option is not supported.")

    hopts = {'line.color': 'black',
             'fill.color': _get_next_color("Histogram"),
             'fill.style': 'solid'}

    ec = _get_kwarg2(kwargs, None, 'edgecolor', 'ec', _convert_color)
    if ec is not None:
        hopts['line.color'] = ec

    fc = _get_kwarg2(kwargs, None, 'facecolor', 'fc', _convert_color)
    if fc is not None:
        hopts['fill.color'] = fc

    if color is not None:
        color = _convert_color(color)
        hopts['line.color'] = color
        hopts['fill.color'] = color

    a = _get_kwarg(kwargs, None, 'alpha')
    if a is not None:
        hopts['fill.opacity'] = a

    htype = _get_kwarg(kwargs, 'bar', 'histtype')
    if htype == 'bar':
        hopts['dropline'] = True
    elif htype == 'step':
        hopts['fill.style'] = 'nofill'
        hopts['line.color'] = hopts['fill.color']
    elif htype != 'stepfilled':
        raise NotImplementedError("The histtype={} option is not supported.".format(htype))

    f = _get_kwarg(kwargs, None, 'fill')
    if f is not None:
        if f:
            hopts['fill.style'] = 'solid'
        else:
            hopts['fill.style'] = 'nofill'

    ls = _get_kwarg2(kwargs, None, 'linestyle', 'ls', _convert_linestyle)
    if ls is not None:
        hopts['line.style'] = ls

    lw = _get_kwarg2(kwargs, None, 'linewidth', 'lw')
    if lw is not None:
        hopts['line.thickness'] = lw

    # Assume using numpy >= 1.5, so do not have to correct normed behavior
    (y, edges) = np.histogram(x, bins=bins, range=range, normed=normed,
                              weights=weights)

    # TODO: some strange behavior going on if .copy() is not used
    xlo = edges[:-1].copy()
    xhi = edges[1:].copy()
    xhw = (xhi - xlo) / 2
    if align == 'mid':
        pass
    elif align == 'left':
        xlo -= xhw
        xhi -= xhw
    elif align == 'right':
        xlo += xhw
        xhi += xhw
    else:
        raise NotImplementedError("The align={} option is not supported.".format(align))

    @add_chips_undo_buffer()
    def doit():
        pychips.add_histogram(xlo, xhi, y, hopts)
        # Not convinced use ot automin/max here is correct
        yax = pychips.get_yaxis()
        if not yax.automin:
            return

        if yax.automax:
            pychips.limits(pychips.Y_AXIS, 0, pychips.AUTO)
        else:
            yr = pychips.get_plot_yrange()
            pychips.limits(pychips.Y_AXIS, 0, yr[1])

    doit()
    return (y, edges, None)


def hlines(y, xmin, xmax, colors='k', linestyles='solid', **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.hlines

    Supported options:
      colors
      linestyles
      linewidth or lw

    At present only scalars are supported for colors and linestyles.
    """

    lopts = {'stem': 'hlines',
             'color': _convert_color(colors),
             'style': _convert_linestyle(linestyles),
             'thickness': _get_kwarg2(kwargs, 1, 'linewidth', 'lw')}

    y = np.atleast_1d(y)
    if y.ndim != 1:
        raise ValueError("y must b a scalar or 1D array")

    xs = np.atleast_1d(xmin)
    xe = np.atleast_1d(xmax)
    if xs.ndim != 1:
        raise ValueError("xmin must be a scalar or 1D array")
    if xe.ndim != 1:
        raise ValueError("xmax must be a scalar or 1D array")

    nlines = y.size
    if nlines == 0:
        raise ValueError("y array must not be empty")
    if xs.size == 1:
        xs = np.repeat(xs, nlines)
    elif xs.size != nlines:
        raise ValueError("xmin must be a scalar or match the size of the y array")
    if xe.size == 1:
        xe = np.repeat(xe, nlines)
    elif xe.size != nlines:
        raise ValueError("xmax must be a scalar or match the size of the y array")

    commands = []
    for (x1, x2, yval) in zip(xs, xe, y):
        commands.append((pychips.add_line,
                         (x1, yval, x2, yval, lopts)))

    @add_chips_undo_buffer()
    def doit():
        for (c, a) in commands:
            c(*a)

    doit()


def imshow(X, cmap=None, norm=None, aspect=None, interpolation=None,
           alpha=None, vmin=None, vmax=None, origin=None, extent=None,
           shape=None, filternorm=1, filterrad=4.0, imlim=None,
           resample=None, url=None, hold=None, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.imshow

    PIL images are not supported, support for RGB(A) images is not guaranteed to
    match.

    Most options are ignored

      interpolation - only none, nearest, bilinear and bicubic are supported,
         other values fall over to bicubic (None or 'none', means linear)
      alpha
      extent
      vmin and vmax
      origin
      aspect - only 'auto' and 'equal' are supported and may not match matplotlib

    """

    if aspect not in [None, 'auto', 'equal']:
        raise NotImplementedError("aspect={} is not supported".format(aspect))

    args = []
    opts = ['stem', 'imshow', 'depth', 90, 'colormap', 'hsv']
    if interpolation is not None:
        if interpolation in ['none', 'nearest']:
            interpolation = 'nearest'
        elif interpolation not in ['bilinear', 'bicubic']:
            _notify("interpolation={} not supported, using bicubic".format(interpolation))
            interpolation = 'bicubic'
    else:
        interpolation = 'bilinear'

    opts.extend(['interpolation', interpolation])

    if alpha is not None:
        opts.extend(['alpha', [alpha, alpha]])

    if X.ndim == 2:
        img2D = X
        args.append(X)

    elif X.ndim == 3:
        img2D = X[:, :, 0]
        if X.shape[-1] > 2:
            args.append(X[:, :, 0])
            args.append(X[:, :, 1])
            args.append(X[:, :, 2])
        if X.shape[-1] > 3:
            args.append(X[:, :, 3])

    else:
        raise ValueError("Unsupported image dimensions: {}".format(X.shape))

    if vmin is not None or vmax is not None:
        thresh = [img2D.min(), img2D.max()]
        if vmin is not None:
            thresh[0] = vmin
        if vmax is not None:
            thresh[1] = vmax
        if thresh[0] > thresh[1]:
            opts.extend(['threshold', [thresh[1], thresh[0]],
                         'invert_colormap', True])
        else:
            opts.extend(['threshold', thresh])

    if extent is not None:
        (l, r, b, t) = extent
        ltype = 'edge'
    else:
        l = 0
        b = 0
        (t, r) = args[0].shape
        t -= 1
        r -= 1
        ltype = 'center'

    tr = imextent(img2D, l, r, b, t, limits=ltype)
    args.append(tr)

    if opts != []:
        args.append(opts)

    @add_chips_undo_buffer()
    def doit():
        try:
            pychips.get_image()
            pychips.delete_image('all')
        except RuntimeError:
            pass

        pychips.add_image(*args)
        pychips.set_axis(['majortick.mode', 'limits'])
        yr = pychips.get_plot_yrange()
        if origin in [None, 'upper']:
            if yr[0] < yr[1]:
                pychips.reverse_axes(pychips.Y_AXIS)
        elif origin == 'lower':
            if yr[0] > yr[1]:
                pychips.reverse_axes(pychips.Y_AXIS)

        if aspect in [None, 'equal']:
            (h, w) = img2D.shape
            pychips.set_plot_aspect_ratio("{}:{}".format(w, h))
        elif aspect == 'auto':
            # pychips.set_plot_aspect_ratio('')
            pychips.set_data_aspect_ratio('')
            pychips.limits(pychips.XY_AXIS, pychips.AUTO, pychips.AUTO)

    doit()


def loglog(**kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.loglog

    Keywords are ignored except that setting basex or basey to a value that
    is not 10 is an error.
    """

    basex = _get_kwarg(kwargs, 10, 'basex')
    basey = _get_kwarg(kwargs, 10, 'basey')
    if basex != 10:
        raise ValueError("basex={} is not supported (only valid value is 10)".format(basex))
    if basey != 10:
        raise ValueError("basey={} is not supported (only valid value is 10)".format(basey))

    pychips.log_scale(pychips.XY_AXIS)


def minorticks_off():
    "See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.minorticks_off"

    pychips.set_axis('all', ['minortick.visible', False])


def minorticks_on():
    "See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.minorticks_on"

    pychips.set_axis('all', ['minortick.visible', True])


def plot(*args, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot

    Currently supports:

      plot(y)         - x=0 to N-1, y can be 1 or 2D
      plot(y,opt)
      plot(x,y)       - x and y can be 1 or 2D
      plot(x,y,opt)

    and multiple versions such as

      plot(x1,y1,x2,y2)
      plot(x1,y1,opt1,x2,y2,opt2)
      plot(x1,y1,opt1,x2,y2,color=...,marker=...)

    The behavior is not guaranteed to be the same as matplotlib, but is hopefully
    close enough.

    opt values are parsed similar to the values for the keyword arguments:
    those that are easily supported by ChIPS are done so, otherwise they
    are ignored or replaced with a default value.

    Supported keyword arguments:

      color     - change the line color (only color names or rgb formats
      or c        such as color='fa2313' are supported)
      linewidth - line width (scaling is not going to be the same)
      or lw
      linestyle - attempts to map between the two different line styles;
      or ls       not that the dashes argument is ignored
      marker    - not all options are supported
      markersize - scaling will not match pyplot
      or ms
      visible   - will hide the curve after displaying it

    The pyplot approach to drawing a 'border' around symbols could be
    mimcked by adding two curves (the second drawing the symbol but
    not filled, and in black), but that is not ideal (and messes up the
    auto-color-changing code).
    """

    plot_args = _handle_plot_args(*args)
    if plot_args == []:
        return

    visible = _get_kwarg(kwargs, True, 'visible')

    @add_chips_undo_buffer()
    def doit():
        for plot_arg in plot_args:
            if plot_arg['type'] == 'xy':
                xs = plot_arg['x']
                ys = plot_arg['y']
                npts = ys.shape[0]

            elif plot_arg['type'] == 'y':
                ys = plot_arg['y']
                npts = ys.shape[0]
                xs = np.arange(npts)

            else:
                raise RuntimeError("Internal error: unrecognized plot type={}".format(plot_arg['type']))

            try:
                opts = plot_arg['opts']
            except KeyError:
                opts = None

            if xs.ndim == 1:
                xs = xs.reshape(npts, 1)
            if ys.ndim == 1:
                ys = ys.reshape(npts, 1)

            ncurves = max(xs.shape[1], ys.shape[1])
            for i in range(ncurves):
                # This appears to be how pyplot behaves when the
                # second dimension does not match.
                try:
                    x = xs[:, i]
                except IndexError:
                    x = xs[:, 0]
                try:
                    y = ys[:, i]
                except IndexError:
                    y = ys[:, 0]

                copts = _get_curve_opts(argstr=opts, **kwargs)
                pychips.add_curve(x, y, copts)
                if not visible:
                    pychips.hide_curve()

    doit()


def savefig(fname, dpi=None, orientation='portrait', papertype=None,
            format=None
            ):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.savefig

    Limited support for options
    """

    popts = {
        'clobber': True,
        'dpi': dpi,
        'orientation': orientation,
        'papersize': papertype,
        'format': format
    }

    todel = set()
    for (k, v) in six.iteritems(popts):
        if v is None:
            todel.add(k)

    for k in todel:
        del popts[k]

    pychips.print_window(fname, popts)


# TODO: support array values for color/size/...
def scatter(x, y, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.scatter

    Only supports a very-limited set of options.

    The attributes of the scatter plot can only be scalars.
    The scaling of the symbols uses a different numeric scale
    to matplotlib.
    """

    xplot = np.ravel(np.asarray(x))
    yplot = np.ravel(np.asarray(y))
    if xplot.size != yplot.size:
        raise ValueError("x and y must be the same size")

    copts = _get_curve_opts('bo', **kwargs)
    pychips.add_curve(xplot, yplot, copts)


def show(*args, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.show

    At present this does nothing.
    """

    pass


def subplot(*args, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.subplot

    Supports
        subplot(n)  where n is a 3-digit integer
        subplot(nrows,ncols,fignum)

    This attempts to delete overlapping plots, but is not guaranteed to match
    matplotlib behavior.

    The polar and projection arguments are not supported, so will error out if set.

    The axisbg argument is supported, and a region is placed at depth=10 below
    the plot with the color, for all colors but white. This is an experimental
    feature and may well be removed.
    """

    polar = _get_kwarg(kwargs, False, 'polar')
    if polar:
        raise ValueError("Polar plots are not supported.")

    if 'projection' in kwargs:
        raise ValueError("The projection keyword is not supported")

    bgcol = _get_kwarg(kwargs, None, 'axisbg', _convert_color)

    nargs = len(args)
    if nargs == 0:
        raise TypeError("subplot requires at least one argument")
    elif nargs == 1:
        plotval = args[0]
        if plotval < 100 or plotval > 999:
            raise ValueError("Single argument to subplot must be a 3-digit integer")
        nrows = plotval // 100
        ncols = (plotval - nrows * 100) / 10
        nplot = plotval - nrows * 100 - ncols * 10
    elif nargs == 3:
        nrows, ncols, nplot = args
    else:
        raise TypeError("subplot takes either 1 or 3 arguments, not {} arguments.".format(nargs))

    if nplot > ncols * nrows:
        raise ValueError("nplot must be <= ncols * nrows")

    margin_left = 0.15
    margin_right = 0.1
    margin_bottom = 0.15
    margin_top = 0.1

    # Estimated visually
    gap_x = 0.08
    gap_y = 0.08

    # Coordinates of the plot in the frame-normalized system
    plot_width = (1.0 - margin_left - margin_right - (ncols - 1) * gap_x) \
        / ncols
    plot_height = (1.0 - margin_bottom - margin_top - (nrows - 1) * gap_y) \
        / nrows

    # (0,0) is top-left plot
    plot_colnum = (nplot - 1) % ncols
    plot_rownum = (nplot - 1) // ncols

    x1 = margin_left + plot_colnum * (plot_width + gap_x)
    x2 = x1 + plot_width

    y1 = margin_bottom + (nrows - 1 - plot_rownum) * (plot_height + gap_y)
    y2 = y1 + plot_height

    # What plots should be deleted; we only do this when one frame is current
    cplots = _get_current_plots()
    todel = []
    if len(cplots) == 1:
        istr = pychips.info(cplots[0])
        if istr is not None:
            for fragment in istr.split("Plot [")[1:]:
                cpos = fragment.find("]")
                if cpos == -1:
                    continue

                plotname = fragment[:cpos]
                try:
                    pobj = pychips.get_plot(plotname)
                    px1 = pobj.leftmargin
                    px2 = 1 - pobj.rightmargin
                    py1 = pobj.bottommargin
                    py2 = 1 - pobj.topmargin
                    if px1 > x2 or px2 < x1 or py1 > y2 or py2 < y1:
                        continue

                    cid = pychips.ChipsId()
                    cid.window = cplots[0].window
                    cid.frame = cplots[0].frame
                    cid.plot = plotname
                    todel.append(cid)

                except:
                    pass

    @add_chips_undo_buffer()
    def doit():
        for cid in todel:
            pychips.delete_plot(cid)

        pychips.add_plot(x1, y1, x2, y2)
        pychips.add_axis(pychips.XY_AXIS, 0, 0, 1)
        if bgcol is not None:
            pychips.add_region([0, 1, 1, 0], [0, 0, 1, 1],
                               ['coordsys', pychips.PLOT_NORM,
                                'fill.color', bgcol, 'fill.style', 'solid',
                                'edge.style', 'noline',
                                'opacity', 1,
                                'depth', 10])

    doit()


def text(x, y, s, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.text

    Unlike matplotlib, this will fail if a pair of axes has not already
    been created (e.g. with subplot, plot, ...).

    Supported keywords:
      color or c
      fontsize or size
      fontstyle or style
      fontweight or weight  TODO
      horizontalalignment or ha
      verticalalignment or va or ma
      rotation
      visible

    """

    opts = {'coordsys': pychips.DATA}
    _handle_text_args(opts, **kwargs)
    vis = _get_kwarg(kwargs, True, 'visible')
    _add_text(x, y, s, vis, opts)


def title(s, *args, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.title

    Currently does not support args or kwargs.
    """

    if len(args) != 0:
        raise ValueError("At present only a label can be given")

    pychips.set_plot_title(s)


def twinx(ax=None):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.twinx

    Does not supporting setting ax.
    """

    if ax is not None:
        raise ValueError("ax can not be set")

    pychips.add_axis(pychips.Y_AXIS, 1, 0, 1)


def twiny(ax=None):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.twiny

    Does not supporting setting ax.
    """

    if ax is not None:
        raise ValueError("ax can not be set")

    pychips.add_axis(pychips.X_AXIS, 1, 0, 1)


def vlines(x, ymin, ymax, colors='k', linestyles='solid', **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.vlines

    Supported options:
      colors
      linestyles
      linewidth or lw

    At present only scalars are supported for colors and linestyles.
    """

    lopts = {'stem': 'vlines',
             'color': _convert_color(colors),
             'style': _convert_linestyle(linestyles),
             'thickness': _get_kwarg2(kwargs, 1, 'linewidth', 'lw')}

    x = np.atleast_1d(x)
    if x.ndim != 1:
        raise ValueError("x must b a scalar or 1D array")

    ys = np.atleast_1d(ymin)
    ye = np.atleast_1d(ymax)
    if ys.ndim != 1:
        raise ValueError("ymin must be a scalar or 1D array")
    if ye.ndim != 1:
        raise ValueError("ymax must be a scalar or 1D array")

    nlines = x.size
    if nlines == 0:
        raise ValueError("x array must not be empty")
    if ys.size == 1:
        ys = np.repeat(ys, nlines)
    elif ys.size != nlines:
        raise ValueError("ymin must be a scalar or match the size of the x array")
    if ye.size == 1:
        ye = np.repeat(ye, nlines)
    elif ye.size != nlines:
        raise ValueError("ymax must be a scalar or match the size of the x array")

    commands = []
    for (y1, y2, xval) in zip(ys, ye, x):
        commands.append((pychips.add_line,
                         (xval, y1, xval, y2, lopts)))

    @add_chips_undo_buffer()
    def doit():
        for (c, a) in commands:
            c(*a)

    doit()


def xlabel(s, *args, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.xlabel

    Currently does not support args or kwargs.
    """

    if len(args) != 0:
        raise ValueError("At present only a label can be given")

    pychips.set_plot_xlabel(s)


def xlim(*args, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.xlim

    """

    return _axlimits(pychips.X_AXIS, *args, **kwargs)


def _axscale(axtype, scale, **kwargs):
    "Worker for xscale/yscale"

    if axtype == pychips.X_AXIS:
        basel = 'basex'

    elif axtype == pychips.Y_AXIS:
        basel = 'basey'

    else:
        raise ValueError("Internal error: unsupported axtype={}".format(axtype))

    if scale == "symlog":
        raise ValueError("The symlog scale is not supported.")

    elif scale == "linear":
        pychips.linear_scale(axtype)

    elif scale == "log":
        baseval = _get_kwarg(kwargs, 10, basel)
        if baseval != 10:
            raise ValueError("{} can only be set to 10, not {}".format(basel, baseval))

        pychips.log_scale(axtype)

    else:
        raise ValueError("Unrecognized scale: {}".format(scale))


def xscale(scale, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.xscale

    Only supports the linear and log options and all keywords are
    currently ignored (unless basex is set to a value other than 10).
    """

    _axscale(pychips.X_AXIS, scale, **kwargs)


def ylabel(s, *args, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.ylabel

    Currently does not support args or kwargs.
    """

    if len(args) != 0:
        raise ValueError("At present only a label can be given")

    pychips.set_plot_ylabel(s)


def ylim(*args, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.ylim

    """

    return _axlimits(pychips.Y_AXIS, *args, **kwargs)


def yscale(scale, **kwargs):
    """See http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.xscale

    Only supports the linear and log options and all keywords are
    currently ignored (unless basex is set to a value other than 10).
    """

    _axscale(pychips.Y_AXIS, scale, **kwargs)


###################################################################
#
# other random routines
#
###################################################################

# because I want to create something similar to the pyplot contour
# example I want a bivariate normal, so

def bivariate_normal(x, y, sigmax=1.0, sigmay=1.0,
                     mux=0.0, muy=0.0, sigmaxy=0.0):
    """See the mathworld documentation at
    http://mathworld.wolfram.com/BivariateNormalDistribution.html
    """

    xoff = x - mux
    yoff = y - muy

    sigma2 = sigmax * sigmay
    rho = sigmaxy / sigma2
    rhoterm = 1.0 - rho * rho
    z = xoff * xoff / (sigmax * sigmax) + \
        yoff * yoff / (sigmay * sigmay) - \
        2.0 * rho * xoff * yoff / sigma2
    normval = 1.0 / (2.0 * np.pi * sigma2 * np.sqrt(rhoterm))
    return normval * np.exp(-z / (2.0 * rhoterm))

# End
